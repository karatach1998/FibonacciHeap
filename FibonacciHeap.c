#include "FibonacciHeap.h"
#include "math.h"
#include <stdlib.h>

enum {FALSE, TRUE};



static inline unsigned maxDegree( unsigned n )
{
	static double FI = 1.618033988749895;// (1 + sqrt(5)) / 2;
	return ceil(log(n)/log(FI));
}



// makeFH: Возвращает дескриптор пустой фибоначчиевой кучи.
FibHeap makeFH( void )
{	
	// Создаем дескриптор фибоначчиевой кучи.
	FibHeap H;

	// Указатель на минимальный узел инициализируем
	// нулевым указателем.
	H.min = NULL;

	// Устанавливаем текущее количество узлов в куче в ноль.
	H.n = 0;

	// Возвращаем созданный дескриптор.
	return H;
}



// insertFH: Вставляет в пирамиду H узел x. Память под узел x
// должна быть выделена заранее, а поле x.key проинициализировано.
void insertFH( FibHeap* H, FHNode* x )
{
	x->degree = 0;   // Устанавливаем степень только что
					 // вставленного узла в ноль.
	x->mark = FALSE; // Устанавливаем флаг в 0.
	x->p = NULL;	 // Так как узел вставляется в 'список корней',
	x->child = NULL; // то он не имеет ни родителя ни дочерних узлов.

	// Если куча - пуста,
	if (H->min == NULL)
		// то x является своим левым и правым братом,
		// а также единственным минимальным элементом в куче.
		H->min = x->left = x->right = x;
	else {
		// Иначе, так как новый узел вставляется слева от минимального,
		// его правым момедом будет минимальный,
		x->right = H->min;
		// а левым - бывшый левый брат для минимального корневого узла.
		x->left = H->min->left;
		// Также следует проверить является ли ключ поступившего
		// элемента меньше ключа минимального узла. Если это так,
		// то стоит обновить указатель на минимальный узел в дескрипторе H,
		// заменив его на x.
		if (x->key < H->min->key)
			H->min = x;
	}
	++H->n; // Увеличиваем число узлов в куче.
}



// minimumFH: Возвращает укаатель на минимальный
// узел фибоначчиевой кучи H.
FHNode* minimumFH( FibHeap* H )
{
	// Вовращаем адрес минимального узла,
	// который хранится в дескрипторе.
	return H->min;
}



// unionFH: Объединяет две фибоначчиевы пирамиды H1 и H2, и возвращает
// объединенную пирамиду. В результате работы функции исходные пирамиды
// H1 и H2 уничтожаются.
FibHeap unionFH( FibHeap* H1, FibHeap* H2 )
{
	// Создаем новую пирамиду.
	FibHeap H;


	if (H1->min == NULL)
		// Если первая куча пуста, то список корней объединенной кучи будет
		// состоять только из списка корней второй кучи H2.min.
		H.min = H2->min;
	else if (H2->min == NULL)
		// Если первая куча не пуста, а пуста вторая H2.min, то список корней
		// объединенной кучи будет состоять из списка корней первой кучи H1.min.
		H.min = H1->min;
	else {
		// Иначе список корней обеих куч не пуст и необходимо выполнить
		// конкатенацию этих списков. Сначала соединим правых братьев
		// минимальных узлов, а потом и сами минимаьлные узлы.

		// Правого брата H1.min связываем с правым братом H2.min.
		H1->min->right->left = H2->min->right;
		H2->min->right->left = H1->min->right;

		// Связываем между собой минимальные узлы H1.min и H2.min.
		H1->min->right = H2->min;
		H2->min->right = H1->min;

		// Устанавливаем H.min на корень, содержащий минимальное значение ключа.
		H.min = (H1->min->key < H2->min->key) ? H1->min : H2->min;
	}
	// Находим общее количество узлов в объединенной пирамиде как сумму
	// количества узлов пирамид, из которых она была составлена.
	H.n = H1->n + H2->n;

	return H;
}



// link: Связывает узел н с узлом x
static void link( FibHeap* H, FHNode* x, FHNode* y )
{
	// 1) Выполняем удаление узла y из списка корней кучи H.
	y->left->right = y->right; // Левого брата y связываем с правым,
	y->right->left = y->left;  // а правого брата y -- с левым.

	// 2) Вставляем узел y в список сыновей узла x слева от него.
	y->right   = x->child; 	  	 // Правый брат у теперь прямой сын x;
	y->left    = x->child->left; // левый -- левый брат прямого сына x.
	x->child->left->right 	= y; // Правый брат левого брата прямого сына x тепер y.
	x->child->left 			= y; // А левый брат прямого сына x теперь y.

	// 3) Снимаем возможную пометку с y.
	y->mark = FALSE;
/*
	// 4) Так как узел x в результате работы процедуры оказывается в списке
	//    корней, то обновим значение минимального узла.
	if (H->min->key > x->key)
		H->min = x;
*/
}



static void consolidate( FibHeap* H )
{
	/*
	 * Далее будем говорить, что корневой узел y СВЯЗЫВАЕТСЯ с корневым узлом x,
	 * если x->key <= y.key и узел y перемещается из списка корней
	 * в список сыновей узла x.
	 */

	const unsigned MAX_DEGREE = maxDegree(H->n); // Максимальная степень узла в куче.
	// Массив способный сохранить указатели на корни со степенями
	// от 0 до максимально возможной степени, зависящей от H->n.
	FHNode* A[MAX_DEGREE + 1];
	FHNode* iterator; // Итератор для прохождения по узлам дерева.
	FHNode* x = NULL; // Первый связываемый узел.
	FHNode* y = NULL; // Второй связываемый узел.
	unsigned d;       // Текущая степень узла.
	unsigned i;       // Индекс узла в массиве A.


	// Инициализируем массив указаьелей на корни.
	for (i = 0; i <= MAX_DEGREE; ++i)
		A[i] = NULL;

	// Проходимся по узлам списка корней. Так элемент отправления совпадает
	// с элементом прибытия, то текущая ситуация определяется исходя из адреса
	// первого связываемого узла.
	for (iterator = H->min; iterator != H->min || !x; iterator = iterator->right)
	{
		x = iterator; // Устанавливаем указатель x на тот же узел,
		              // на который указывает итератор.
		d = x->degree; // Сохраняем текущую степень узла x в переменной d.
		// Пока в пройденной части кучи остались несвязанные узлы степени d.
		while (A[d] != NULL) {
			y = A[d]; // Устанавливаем указатель y на узел со степенью d
			          // из пройденной части списка корней.
			if (x->key > y->key)
				// Если ключ узла x больше ключа y,
				// то связываем узел x с узлом y.
				link(H, y, x);
			else
				// Иначе связываем узел x с узлом y.
				link(H, x, y);
			// Убираем бывший корень степени d из списка кандидатов для связывания.
			A[d] = NULL;
			// Увеличиваем текущую степень, узла x, на 1.
			d += 1;
		}
		// Помещаем корень x в список корней-кандидатов стпени d для склеивания.
		A[d] = x;
	}
	H->min = NULL;
	// Для всех узлов степени i.
	for (i = 0; i <= MAX_DEGREE; ++i)
		if (A[i] != NULL)
			// Если имеется корень текущей степени.
			if (H->min == NULL)
				// Если корень степени i первый из кандидатов на минимальный узел.
				H->min = A[i];
			else {
				// Добавляем корень A[i] в список корней.
				A[i]->right = H->min->right;
				A[i]->left = H->min;
				H->min->right->left = A[i];
				H->min->right = A[i];
				// Обновляем минимальный элемент.
				if (H->min->key > A[i]->key)
					H->min = A[i];
			}
}



// extractMinFH: Удаляет из фибоначчиевой кучи минимальный узел и вовращает
// указатель на него. Именно в этой функции выполняется реорганизация кучи
// путем компактизации (уплотнения) её межузловых связей.
FHNode* extractMinFM( FibHeap* H )
{
	// Создаем и инициализируем указатель на текущий
	// минимальный элемент кучи.
	FHNode* z = H->min;


	if (z != NULL) {
		// Если изначально в списке корней был хотя бы один узел, то:
		//
		// 1) Заменяем удаляемый элемент его дочерними узлами,
		//    в случае если таковые имеются.

		FHNode* current; // указатель на текущий дочерний узел.

		// Проходимся по сыновьям удаляемого узла,
		// для которых он пока является родителем.
		for (current = z->child; current->p != NULL; current = current->right)
			// Для каждого такого сына обозначаем отсутствие родителя.
			current->p = NULL;

		// Связываем правого брата current с правым братом z.
		current->right->right = z->right;
		z->right->left = current->right;

		// Связываем current с левым братом z.
		current->left = z->left;
		z->left->right = current;

		// 2) Если правым братом узла z является он сам, то...
		if (z == z->right)
			// ... это означает, что z не имеет ни дочерних узлов ни братьев
			// и после его удаления куча ддолжна стать пустой.
			H->min = NULL;
		else {
			// Иначе выполняем 'уплотнение' списка корней.
			// Для этого устанавливаем указатель на минимальный элемент на
			// правого брата узла z. Сейчас это не играет никакой роли.
			H->min = z->right;
			// А также вызываем процедуру уплотнения фибоначчиевой кучи.
			consolidate(H);
		}

		// 3) Уменьшаем число узлов в куче на 1.
		H->n -= 1;
	}

	// Возвращаем минимальный элемент кучи.
	return z;
}
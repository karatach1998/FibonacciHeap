/*
 * Для сокращения письма будем иногда писать с. к. вместо список корней.
 */

#include <stdlib.h>
#include <math.h>
#include "FibonacciHeap.h"


enum {FALSE, TRUE};


// СОЗДАНИЕ И УНИЧТОЖЕНИЕ
// ==========================================================================


FbHeap makeFbHeap( void )
{
    FbHeap H;       // Создание дескриптора новой кучи.
    H.min = NULL;   // Инициализация адреса минимального элемента пустым указателем.
    H.n   = 0;      // Инициализация текущего количества узлов кучи нулем.
    return H;       // Возврат проинициализированного дескриптора.
}



static void recListDelete( FbNode* pNode )
{
    FbNode* next; // Указатель на следующий за текущим узел.

    /*
     * Для простоты будем использовать двухсвязный список,
     * на который указыает элемент pNode, как односвязный.
     *
     * Для бедем двигаться по нему только в направлении правого соседа.
     * Также предварительно установим поле right для левого соседа
     * элемента pNode равным NULL.
     */

    // Устанавливаем признак конца списка.
    pNode->left->right = NULL;

    while (pNode != NULL) {
        // Сохраняем указатеь на узел, следующий за текущим.
        next = pNode->right;

        if (pNode->child != NULL)
            // Если у данного узла есть дочерние элементы,
            // то вызовем эту функцию и для него.
            recListDelete(pNode->child);

        // Освобождаем память, занимаемую узлом.
        free(pNode);
        // Восстанавливаем сохраненное значение.
        pNode = next;
    }
}



void doneFbHeap( FbHeap* H )
{
    // Вызов рекурсивной фнкции удаления списков.
    recListDelete(H->min);
}


// ОПЕРАЦИЯ ПРЕДИКАТ
// ==========================================================================


int isEmptyFb( const FbHeap* H )
{ return H->min == NULL; }


// ОСНОВНЫЕ ОПЕРАЦИИ ВЗАИМОДЕЙСТВИЯ
// ==========================================================================


// swapPtr: Обмен указателей на нетипизированные указатели.
static inline void swapPtr( void** restrict p1, void** restrict p2 )
{
    void* tmp = *p1;
    *p1 = *p2;
    *p2 = tmp;
}



// concatLists: Соединяет два циклических двусвязных списка
// путем вставки списка list2 в список list1.
static void concatLists( FbNode* list1, FbNode* list2 )
{
    // Меняем указатели на левый элемент для правых соседей.
    swapPtr((void**) &list1->right->left, (void**) &list2->right->left);
    // Меняеи указатели на правый элемент.
    swapPtr((void**) &list1->right, (void**) &list2->right);
}



void insertFb( FbHeap* H, TData data )
{
    // Выделяем память под новый узел.
    FbNode* pNode   = (FbNode*) malloc(sizeof(FbNode));
    pNode->data     = data;     // Инициализируем поле данных.
    pNode->parent   = NULL;     // У узла нет родителя.
    pNode->child    = NULL;     // У узла нет дочерних узлов.
    pNode->right    = pNode;    // Узел сам себе правый ...
    pNode->left     = pNode;    // ... и левый сосед.
    pNode->degree   = 0;        // У узла нет дочерних узлов.
    pNode->mark     = FALSE;    // Узел не помечен.

    if (H->min != NULL) {
        // Если с. к. кучи H.min содержит элементы, то включить в него
        // список, образованный элементом pNode.
        concatLists(H->min, pNode);

        if (H->min->data.key > pNode->data.key)
            // Если ключ нового элемента меньше ключа текущего минимального
            // элемента, то обновляем соответствующее поле в дескрипторе.
            H->min = pNode;
    } else
        // Иначе список корней кучи H будет состоять
        // только из созданного элемента pNode.
        H->min = pNode;

    // Увеличиваем число узлов в куче.
    H->n += 1;
}



TData getMinimumFb( FbHeap* H )
{
    if (H->min == NULL)
        // Если куча пуста, то возвращаем нулевые данные.
        return (TData) {0};
    else
        // Иначе возвращаем поле данных минимально элемента.
        return H->min->data;
}



FbHeap mergeFb( FbHeap* H1, FbHeap* H2 )
{
    // Создание дескриптора итоговой кучи.
    FbHeap H;

    if (H1->min == NULL)
        // Если список корней кучи H1 пуст, с. к. итоговой кучи будет
        // состоять из узлов в с. к. кучи H2.
        H.min = H2->min;
    else if (H2->min == NULL)
        // Аналогично для кучи H2.
        H.min = H1->min;
    else {
        // Выполняем слияние списков корней куч H1 и H2.
        concatLists(H1->min, H2->min);

        // Определяем минимальный из двух минимальных узлов куч H1 и H2.
        H.min = (H1->min->data.key <= H2->min->data.key) ? H1->min : H2->min;
    }

    // Определяем количество узлов в итоговой куче.
    H.n = H1->n + H2->n;

    // Возвращаем дескриптор итоговой кучи.
    return H;
}



// insertNode: Вставляет элемент pNode в список list
// и возвращает указатель на него.
FbNode* insertNode( FbNode* list, FbNode* pNode )
{
    // Правым братом pNode становится правый брат list.
    pNode->right = list->right;
    // Левым братом pNode становиться сам list.
    pNode->left = list;
    // Левым братом list->right становится pNode.
    list->right->left = pNode;
    // Правым братом list становится pNode.
    list->right = pNode;
    // Возврат pNode.
    return pNode;
}



// deleteNode: Возвращает указатель на элемент списка, в котором исключен
// элемент pNode ранее принадлежаций этому списку.
FbNode* deleteNode( FbNode* pNode )
{
    if (pNode == pNode->right)
        // Если pNode -- единственный узел в списке, то после его удаления
        // в этом списке не останится элементов, поэтому функция возвращает
        // пустой указатель.
        return NULL;
    else {
        // Иначе левый сосед pNode связывается с его правым соседом;
        pNode->left->right = pNode->right;
        // а правый сосед -- с левым.
        pNode->right->left = pNode->left;
        // Возврат указателя на правого соседа.
        return pNode->right;
    }
}



// linkFb: Связывает два узла фибоначчиевой кучи H, делая x родителем y-ка.
void linkFb( FbHeap* H, FbNode* y, FbNode* x )
{
    // 1) Удаление y из списка корней H;
    y->left->right = y->right;
    y->right->left = y->left;

    // 2) Делаем y дочерним узлом x, увеличиваем x->degree;
    y->parent = x;
    if (x->child == NULL)
        x->child = y->left = y->right = y;
    else
        insertNode(x->child, y);
    x->degree += 1;

    // 3) y->mark = FALSE.
    y->mark = FALSE;
}



// consolidate: Выполняет уплотнение списка корней H.
static void consolidate( FbHeap* H )
{
    /*
     * Далее будем говорить, что корневой узел y СВЯЗЫВАЕТСЯ с корневым узлом x,
     * если x->data <= y.data и узел y перемещается из списка корней
     * в список сыновей узла x.
     */

    const double Fi = (1+sqrt(5))/2;
    // Максимальная степень узла в куче H из H.n элементов.
    const unsigned MaxDegree = (const unsigned int) (log(H->n) / log(Fi));

    FbNode* A[MaxDegree + 1];   // Массив корней, ожидающих связывания.

    FbNode* begin;              // Указатель на первый элемент последовательности.
    FbNode* end;                // Указатель на последний элемент
                                // последовательности.
    FbNode* x = NULL;           // Указатель на первый связываемый узел.
    FbNode* y = NULL;           // Указатель на второй связываемый узел.
    unsigned d;                 // Текущая степень узла x.
    unsigned i;

    // Инициализация массива указателей на корни нулевыми указателями.
    for (i = 0; i <= MaxDegree; ++i)
        A[i] = NULL;


    // Проходимся по списку корней кучи H.
    for (begin = H->min, end = H->min->left; x != end; )
    {
        x = begin;   // Текущий кандидат для связывания.
        begin = begin->right;
        d = x->degree;  // Его степень.

        // Пока в массиве корней-кандидатов для связывания
        // есть корни степени d.
        while (A[d] != NULL) {
            // Второй связываемый узел выбирается из массива
            // корней-кандидатов.
            y = A[d];

            // Далее определяем который из узлов x и y
            // будет родителем второго.
            if (x->data.key > y->data.key)
                // Узел y становится родителем x.
                swapPtr((void**) &x, (void**) &y);

                // Узел x становиться родителем y.
            linkFb(H, y, x);

            // Удаляем узел степени d из списка кандидатов A.
            A[d] = NULL;

            // Увеличиваем текущую степень узла x.
            ++d;
        }

        // Узел x становиться кандидатом на связывание степени d.
        A[d] = x;
    }


    H->min = NULL; // Обнуляем указатель на минимальный элемент.
    for (i = 0; i <= MaxDegree; ++i)
        // Ищим в массиве A адреса узлов аерхнего уровня.
        if (A[i] != NULL)
            if (H->min == NULL)
                // Если минимальный узел равен нулевому указателю,
                // то создаем список из одного узла A[i].
                H->min = A[i]->left = A[i]->right = A[i];
            else if (H->min->data.key > insertNode(H->min, A[i])->data.key)
                // Иначе, если минимальное значение ключа меньше
                // ключа в узле A[i], то обноадяем минимальный эелемент кучи.
                H->min = A[i];
}


TData extractMinFb( FbHeap* H )
{
    // Создаем и инициализируем указатель на текущий
    // минимальный элемент кучи.
    FbNode* z = H->min;

    if (z != NULL) {
        if (z->child != NULL) {
            FbNode* begin;  // Указатель на текущий дочерний узел узла z.
            FbNode* end;    // Указатель на последний узел в списке
                            // дочерних узлов z.

            for (begin = z->child, end = z->child->left;
                 begin != end; begin = begin->right)
                // Убираем родителя у каждого дочернего элемента узла z.
                begin->parent = NULL;

            // Выполняем то же действие отдельно для последнего
            // элемента последоватльности.
            begin->parent = NULL;

            // Добавляем список дочерних узлов удаляемого элемента
            // в список корней.
            concatLists(H->min, z->child);
        }

        if ((H->min = deleteNode(z)) != NULL)
            // Если после удаления узла z в списке корней кучи H остались
            // корни, то выполним уплотнение этого списка корней.
            consolidate(H);

        // Уменьшаем количество элементов в куче H.
        H->n -= 1;

        // Сохраняем полезную информацию, хранящуюся в узле,
        // во временной переменной.
        TData tmp = z->data;
        // Освобождаем память, занимаемую узлом z.
        free(z);
        // Возвращаем сохраненную информацию.
        return tmp;
    } else
        // Если же куча H оказалась пустой, то возвращаем нулевые данные.
        return (TData) {0};
}



// cutFb: Перемещает узел x в список корней кучи H, удаляет его из списка
// дочерних элементов узла y.
static void cutFb( FbHeap* H, FbNode* x, FbNode* y )
{
    // Удаляем x из списка дочерних узлов элемента y.
    y->child = deleteNode(x);
    y->degree -= 1;
    // Аставляем узел x в спиок корней.
    insertNode(H->min, x);
    // Удаляем у нового корня родителя.
    x->parent = NULL;
    // Снимаем пометку с узла x.
    x->mark = FALSE;
}



static void cascadingCutFb( FbHeap* H, FbNode* y )
{
    FbNode* z = y->parent; // Указатель на родителя y.

    if (z != NULL)
        // Если y не является корневым.
        if (y->mark == FALSE)
            // Если y потерял сына, и еше не был отмечен, то отмечаем его.
            y->mark = TRUE;
        else {
            // Если y потерял сына, но уже был отмечен, то выполним вырезание
            // этого узла y и повторим всё то же уже для его родителя.
            cutFb(H, y, z);
            cascadingCutFb(H, z);
        }
}



void decreaseKeyFb( FbHeap* H, FbNode* x, TKey k )
{
    if (k < x->data.key) {
        // Если новое значение ключа не превышает старое, то выполним
        // присваивание значения k ключу информационной части узла x.
        x->data.key = k;

        FbNode* y = x->parent; // Указатель на родителя.

        if (y != NULL && x->data.key > y->data.key) {
            // Если у узла x есть родитель и его ключ теперь
            // оказался меньшим, то:

            // 1) Выполним перенос узла x в список корней кучи H.
            cutFb(H, x, y);

            // 2) Произведем поиск помеченных узлов для переноса в с. к.
            //    или узлов, подлежащих пометке.
            cascadingCutFb(H, y);
        }

        if (x->data.key < H->min->data.key)
            // Если новое значение ключа окажется наименьшим в куче,
            // то обновим указатель на минимальный элемент в дескрипторе кучи.
            H->min = x;
    }
}



void deleteFb( FbHeap* H, FbNode* x )
{
    FbNode* y = x->parent;  // Указатель на родителя.

    if (y != NULL) {
        // Если x не является корневым узлом,
        // то вырезаем его в список корней ...
        cutFb(H, x, y);
        // ... и применяем каскадное вырезание к его родителю y.
        cascadingCutFb(H, y);
    }

    // Устанавливаем указатель на минимальный узел на x.
    H->min = x;

    // Выполняем извлечение минимального узла.
    extractMinFb(H);
}


// ДОПОЛНИТЕЛЬНЫЕ ОПЕРАЦИИ ВЗАИМОДЕЙСТВИЯ
// ==========================================================================


unsigned sizeFb( FbHeap* H )
{ return H->n; }

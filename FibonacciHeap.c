#include "FibonacciTree.h"


// makeFH: Возвращает дескриптор пустой фибоначчиевой кучи.
FibHeap makeFH( void )
{	
	// Создаем дескриптор фибоначчиевой кучи.
	FibHeap H;

	// Указатель на минимальный узел инициализируем
	// нулевым указателем.
	H.min = NULL;

	// Устанавливаем текущее количество узлов в куче в ноль.
	H.n = 0;

	// Возвращаем созданный дескриптор.
	return H;
}



// insertFH: Вставляет в пирамиду H узел x. Память под узел x
// должна быть выделена заранее, а поле x.key проинициализировано.
void insertFH( FibHeap* H, FHNode* x )
{
	x->degree = 0;  // Устанавливаем степень только что
					// вставленного узла в ноль.
	x->mark = 0;	// Устанавливаем флаг в 0.
	x->p = NULL;	// Так как узел вставляется в 'список корней',
	x->child = NULL;// то он не имеет ни родителя ни дочерних узлов.

	// Если куча - пуста,
	if (H->min == NULL)
		// то x является своим левым и правым соседом,
		// а также единственным минимальным элементом в куче.
		H->min = x->left = x->right = x;
	else {
		// Иначе, так как новый узел вставляется слева от минимального,
		// его правым момедом будет минимальный,
		x->right = H->min;
		// а левым - бывшый левый сосед для минимального корневого узла.
		x->left = H->min->left;
		// Также следует проверить является ли ключ поступившего
		// элемента меньше ключа минимального узла. Если это так,
		// то стоит обновить указатель на минимальный узел в дескрипторе H,
		// заменив его на x.
		if (x->key < H->min->key)
			H->min = x;
	}
	++H->n; // Увеличиваем число узлов в куче.
}



// minimumFH: Возвращает укаатель на минимальный
// узел фибоначчиевой кучи H.
FHNode* minimumFH( FibHeap* H )
{
	// Вовращаем адрес минимального узла,
	// который хранится в дескрипторе.
	return H->min;
}



// unionFH: Объединяет две фибоначчиевы пирамиды H1 и H2, и возвращает
// объединенную пирамиду. В результате работы функции исходные пирамиды
// H1 и H2 уничтожаются.
FibHeap unionFH( FibHeap* H1, FibHeap* H2 )
{
	// Создаем новую пирамиду.
	FibHeap H;


	if (H1.min == NULL)
		// Если первая куча пуста, то список корней объединенной кучи будет
		// состоять только из списка корней второй кучи H2.min.
		H.min = H->min;
	else if (H2.min == NULL)
		// Если первая куча не пуста, а пуста вторая H2.min, то список корней
		// объединенной кучи будет состоять из списка корней первой кучи H1.min.
		H.min = H1->min;
	else {
		// Иначе список корней обеих куч не пуст и необходимо выполнить
		// конкатенацию этих списков. Сначала соединим правых соседей
		// минимальных узлов, а потом и сами минимаьлные узлы.

		// Правого соседа H1.min связываем с правым соседом H2.min.
		H1->min.right.left = H2->min.right;
		H2->min.right.left = H1->min.right;

		// Связываем между собой минимальные узлы H1.min и H2.min.
		H1->min.right = H2->min;
		H2->min.right = H1->min;

		// Устанавливаем H.min на корень, содержащий минимальное значение ключа.
		H->min = (H1->min.key < H2->min.key) ? H1->min : H2->min;
	}
	// Находим общее количество узлов в объединенной пирамиде как сумму
	// количества узлов пирамид, из которых она была составлена.
	H.n = H1->n + H2->n;
}
